# API Reference

For specifics on the exact types of these components/functions/values, please check the implementation. Autogenerated documentation is forthcoming, once [TypeDoc supports Typescript 1.8](https://github.com/TypeStrong/typedoc/issues/210).

## Core

### `Stack`

`Stack`s are the basic unit of layout. Any direct children will be automatically styled and sized to overlay on one another, stacking in the Z direction and matching in vertical/horizontal dimensions. `Stack`s may be freely nested.

#### Props

- `className?`: space-separated DOM class names to be merged with the default class names.
- `pixelRatio?`: the desired pixel density of this chart. See [`window.devicePixelRatio`](https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio). Performance may suffer with higher values. This value is not transparently applied and must be explicitly respected by any contained `Layer`s (the built-in ones all do).

<hr/>

### `ChartProvider`

`ChartProvider` is the parent of all state-managed layers in react-layered-chart. It creates almost no DOM of its own, but is instead a wrapper around react-redux's [`Provider`](https://github.com/reactjs/react-redux/blob/master/docs/api.md#provider-store) that mediates between its own props and state that is automatically loaded/computed.

#### Props

- `seriesIds`: a list of all the series that are present in this chart. IDs are arbitrary and must be unique within a single `ChartProvider`. Series IDs not present here will be silently ignored.
- `loadData`: a stateless function to load the appropriate data for all series. Called whenever `ChartProvider` needs new data. This is where you should do caching or other loading optimizations. Avoid using an inline definition, as that creates a new function object, and data must be reloaded whenever `loadData` changes.
- `className?`: space-separated DOM class names to be merged with the default class names.
- `pixelRatio?`: the desired pixel density of this chart. See [`window.devicePixelRatio`](https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio). Performance may suffer with higher values. This value is not transparently applied and must be explicitly respected by any contained `Layer`s (the built-in ones all do). If specified here, you do not need to specify this value on any contained `Stack`s.
- `chartId?`: an arbitrary, globally-unique ID for the state of this chart that maintains a reference across mount/unmount cycles.
- `defaultState?`: UI state to seed the internal store with. This value is only respected once, at initialization time.
- `onLoadStateChange?`: called with the load states of all series whenever any one of them changes.
- `onError?`: called with the error state of all series whenever any one of them changes.
- `includeResizeSentinel?`: if `false`, prevents the automatic addition of a `ConnectedResizeSentinelLayer`. Use this option if you have layouts or styles that cause the included sentinel layer to incorrectly report the physical chart size. Be sure to replace it with your own `ConnectedResizeSentinelLayer`, otherwise your chart won't render with the correct dimensions!

#### Controlled Props

These props come in read-write pairs and implement the ["controlled component" pattern](https://facebook.github.io/react/docs/forms.html#controlled-components). The "value" props unconditionally trump any automatically-computed values. The "on change" props are called any time the automatically-computed values change to give the parent a chance to incorporate those changes. You can provide any combination of these parameters; providing a "value" prop doesn't imply you need an "on change" prop, nor vice versa.

- `xDomain?`
- `onXDomainChange?()`
- `yDomains?`
- `onYDomainsChange?()`
- `selection?`
- `onSelectionChange?()`
- `hover?`
- `onHoverChange?()`

## Layers

To see some layers in action, check out the example page.

### Data Layers

These components render different types of visualizations for data. They all follow the same basic pattern of accepting props for:

- the data they are to render; usually, an array named `data`
- `xDomain`, which describes what horizontal domain they're currently covering so they can render the appropriate subset of data
- usually `yDomain`, which describes what vertical domain they're currently covering so they can render the data in the appropriate visual location

And some combination of `color`, `font`, `yScale` or other display-related props.

The layers in this category are:

- `BarLayer`
- ~~`BrushLayer`~~ (deprecated)
- `BucketedLineLayer`
- `HoverLineLayer`
- `PointLayer`
- `SimpleLineLayer`
- `SpanLayer`

Additionally, these layers have "connected" variants that replace the `xDomain`, `yDomain` and `data` (or analogous) props with a `seriesId` prop that specifies which data they should read. These layers must be inside a `ChartProvider` to work correctly:

- `ConnectedBarLayer`
- ~~`ConnectedBrushLayer`~~ (deprecated)
- `ConnectedBucketedLineLayer`
- `ConnectedHoverLineLayer`
- `ConnectedPointLayer`
- `ConnectedSimpleLineLayer`
- `ConnectedSpanLayer`
- `ConnectedSelectionBrushLayer`

<hr/>

### `XAxisLayer`

This component renders the X domain. By default, it interprets the numerical value as a timestamp, but you can specify a different scale and set of tick formats to change this behavior.

#### Props

- `xDomain`: the X domain to display on this layer.
- `scale?`: a [d3-scale](https://github.com/d3/d3-scale) constructor function. Only continuous scales are supported. Defaults to `scaleTime`.
- `ticks?`: passed through to [`computeTicks`](#computeticksscale-ticks-tickformat).
- `tickFormat?`: passed through to [`computeTicks`](#computeticksscale-ticks-tickformat).
- `color?`: a string specifying the color to use for ticks and labels.
- ~~`font?`~~ (**deprecated**, use CSS rules instead): a legal [CSS `font` value](https://developer.mozilla.org/en-US/docs/Web/CSS/font), such as `'normal 400 12px Helvetica'`.

There is a `ConnectedXAxisLayer` that accepts the same props, except with `seriesId` instead of `xDomain`.

<hr/>

### `YAxisLayer`

This component renders one or more Y domains, lined up next to each other on the left side of the rendering area.

**Note**: if you add, remove, rearrange or splice items in the `axes` prop, the animation logic will be unable to figure out that the items have shifted in position or otherwise changed in "identity". This will cause animations to jitter or otherwise look bad as it animates between values that weren't intended to be animated between. Provide locally-unique `axisId` values for each item in `axes` if this happens.

#### Props

- `axes`: an array of all the Y axes to render. Each object has the following fields:
    - `yDomain`: the `Interval` to render for this axis.
    - `scale?`: a [d3-scale](https://github.com/d3/d3-scale) constructor function. Only continuous scales are supported. Defaults to `scaleLinear`.
    - `ticks?`: passed through to [`computeTicks`](#computeticksscale-ticks-tickformat).
    - `tickFormat?`: passed through to [`computeTicks`](#computeticksscale-ticks-tickformat).
    - `color?`: a string specifying the color to use for ticks and labels.
    - `axisId?`: a unique ID to identify this axis. Used to prevent jittery animations when adding/removing/rearranging axes.
- ~~`font?`~~ (**deprecated**, use CSS rules instead): a legal [CSS `font` value](https://developer.mozilla.org/en-US/docs/Web/CSS/font), such as `'normal 400 12px Helvetica'`.
- `backgroundColor?`: a string specifying a color to draw behind the axis, which is useful since the Y axis often overlaps the data. Defaults to `rgba(255, 255, 255, 0.8)`.
- `shouldZoom?(event, axisId)`: a callback that accepts a `MouseEvent` and returns a boolean specifying if this event should be used for zooming.
- `shouldPan?(event, axisId)`: a callback that accepts a `MouseEvent` and returns a boolean specifying if this event constitutes the beginning of a pan gesture.
- `onZoom?(factor, anchorBias, axisId)`: fired when the user performs a legal zoom gesture. See `zoomInterval` for an explanation of the parameters.
- `onPan?(logicalUnits, axisId)`: fired when the user moves their mouse during a legal pan gesture.
- `zoomSpeed?`: a constant factor to adjust the sensitivity of the zooming gesture for different scroll velocities.

There is a `ConnectedYAxisLayer` that accepts the same props, except each item in `axes` should specify a `seriesId` instead of both `yDomain` and `axisId`, and `axisId` in callbacks will be the `seriesId`.  This also includes shortcuts for enabling y-axis controls:
- `enablePan?`: whether or not allow pan gestures. Has no effect if `shouldPan` or `onPan` is defined.  Default `false`
- `enableZoom?`: whether or not allow zoom gestures. Has no effect if `shouldZoom` or `onZoom` is defined.  Default `false`

<hr/>

### ~~`AutoresizingCanvasLayer`~~

**This component is deprecated. Use [`PollingResizingCanvasLayer`](#pollingresizingcanvaslayer) instead.**

A component that wraps and exposes a `<canvas>` that (via polling) matches the size of its containing `Stack`. This class does no rendering of its own, but provides a well-behaved blank canvas for a parent component to draw on. All built-in data-rendering layers are based on this component in combination with the `NonReactRender` decorator.

#### Props

- `onSizeChange()`: a function called with no arguments when the size changes, usually, some kind of render method.
- `className?`: space-separated DOM class names to be merged with the default class names.

#### Instance Methods

- `getCanvasElement()`: returns the `<canvas>` element for this layer.
- `getDimensions()`: returns the true `{ width, height }` of this layer.

#### Static Methods

- `resetCanvas(canvasLayer, pixelRatio?)`: clears and resizes the underlying `<canvas>` for the given `canvasLayer` in preparation for a rendering frame. Additionally, it translates the canvas by half a pixel to get crisper rendering behavior. Returns `{ width, height, context }`.

<hr/>

### `PollingResizingCanvasLayer`

A component that wraps and exposes a `<canvas>` that (via polling) matches the size of its containing `Stack`. This class does no rendering of its own, but provides a well-behaved blank canvas for a parent component to draw on. All built-in data-rendering layers are based on this component in combination with the `NonReactRender` decorator.

#### Props

- `onSizeChange()`: a function called with no arguments when the size changes, usually, some kind of render method.
- `pixelRatio?`: the pixel ratio this `<canvas>` should render at. See [`Stack`](#stack) for more on this value.

#### Instance Methods

- `getCanvasElement()`: returns the `<canvas>` element for this layer.
- `getDimensions()`: returns the true `{ width, height }` of this layer.
- `resetCanvas()`: clears and resizes the underlying `<canvas>` in preparation for a rendering frame. Returns `{ width, height, context }`.

<hr/>

### `InteractionCaptureLayer`

This layer displays nothing, but captures all mouse events and translates them into callbacks or (in the case of the "connected" variant) fires actions.

#### Props

- `domain`: specifies the X domain this layer currently covers so it can translate mouse positions to logical values.
- `xDomain` (**deprecated**): Same as domain.
- `direction?`: specifies the direction to track mouse events.  Default: Direction.HORIZONTAL
- `shouldZoom?(event)`: a callback that accepts a `MouseEvent` and returns a boolean specifying if this event should be used for zooming.
- `shouldPan?(event)`: a callback that accepts a `MouseEvent` and returns a boolean specifying if this event constitutes the beginning of a pan gesture.
- `shouldBrush?(event)`: a callback that accepts a `MouseEvent` and returns a boolean specifying if this event constitutes the beginning of a brush (selection) gesture.
- `onZoom?(factor, anchorBias)`: fired when the user performs a legal zoom gesture. See `zoomInterval` for an explanation of the parameters.
- `onPan?(logicalUnits)`: fired when the user moves their mouse during a legal pan gesture.
- `onBrush?(logicalUnitInterval?)`: fired when the user moves their mouse during a legal brush gesture. Called with `null` if the selection is cleared.
- `onHover?(logicalPosition)`: fired when the user hovers over the chart.
- `zoomSpeed?`: a constant factor to adjust the sensitivity of the zooming gesture for different scroll velocities.

#### `ConnectedInteractionCaptureLayer` Props

This variant of the layer replaces the callbacks with simple `true`/`false` settings to enable different types of gestures. The interpreted results are automatically fired as actions on containing `ChartProvider`.

- `enablePan?`: whether or not to fire events for pan gestures. Default `false`.
- `enableZoom?`: whether or not to fire events for zoom gestures. Default `false`.
- `enableHover?`: whether or not to fire events for hover gestures. Default `false`.
- `enableBrush?`: whether or not to fire events for brush gestures. Default `false`.
- `shouldZoom?()`: same as above.
- `shouldPan?()`: same as above.
- `shouldBrush?()`: same as above.
- `zoomSpeed?`: same as above.

<hr/>

### `ConnectedResizeSentinelLayer`

This layer accepts no props. It polls itself to determine its size, and fires and action on the containing `ChartProvider` whenever it changes. This value is used to determine what density to load data at. An instance of this layer is auto-injected into every `ChartProvider`; you shouldn't need to make your own unless styling or layout rules make the default placement of the layer compute incorrect values, which is rare. If you do define your own, note that you only need one instance.

## State Management

### `ChartProviderState`

An opaque type that represents all of the internal chart state. You should not read from this type directly, but instead use the provided selectors and action creators to read and write to it, respectively.

<hr/>

### Selectors

These [selectors](https://github.com/reactjs/reselect) take the entire `ChartProviderState` and return one facet of the state. Several of them are counterparts to the "controlled props" on `ChartProvider`.

- `selectXDomain(state)`
- `selectYDomains(state)`
- `selectHover(state)`
- `selectSelection(state)`
- `selectData(state)`
- `selectIsLoading(state)`
- `selectError(state)`
- `selectChartPixelWidth(state)`

You can use these in a [`connect`](https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options)ed component like so (assuming the component will be used inside a `ChartProvider`):

```tsx
import { connect } from 'react-redux';
import { selectXDomain, ChartProviderState } from 'react-layered-chart';

class ExampleComponent extends React.Component<...> {
  render() {
    return <div>{this.props.xDomain}</div>;
  }
}

function mapStateToProps(state: ChartProviderState) {
  return {
    xDomain: selectXDomain(state)
  };
}

export default connect(mapStateToProps)(ExampleComponent);
```

<hr/>

### Action Creators

These action creators are analogous to some of the "controlled props" on `ChartProvider`. They are intended to be used with [`connect`](https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options) and, optionally, [`bindActionCreators`](http://redux.js.org/docs/api/bindActionCreators.html).

- `setXDomain(domain)`
- `setYDomains(domains)`
- `setHover(hover)`
- `setSelection(selection)`

You can use these in a [`connect`](https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options)ed component like so (assuming the component will be used inside a `ChartProvider`):

```tsx
import { Dispatch, bindActionCreators } from 'redux';
import { connect } from 'react-redux';
import { setXDomain } from 'react-layered-chart';

class ExampleComponent extends React.Component<...> {
  render() {
    return <div onClick={() => this.props.setXDomain(...)}/>;
  }
}

function mapDispatchToProps(dispatch: Dispatch) {
  return bindActionCreators({ setXDomain }, dispatch);
}

export default connect(null, mapDispatchToProps)(ExampleComponent);
```

## Utilities

### Decorators

#### `NonReactRender`

A class decorator that defers the bulk of rendering work until the next [animation frame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame). Useful primarily for expensive rendering that cannot be represented in the virtual DOM, such as when rendering to a `<canvas>`. You must define a method named `nonReactRender` that does the actual work of rendering.

You can access a mixin version at `NonReactRenderMixin`.

```tsx
import { NonReactRender } from 'react-layered-chart';

@NonReactRender
class ExampleComponent extends React.Component<...> {
  render() {
    return <canvas ref='canvas'/>;
  }

  nonReactRender() {
    const canvas = this.refs.canvas;
    // Do the actual rendering work.
  }
}
```

<hr/>

#### `PixelRatioContext`

A class decorator to allow a class to receive a context value called `pixelRatio` that specifies the pixel density for this chart. See [`Stack`](#stack) for more on this value. This context value only exists when the class is inside a `Stack` or `ChartProvider`.

You can access a mixin version at `PixelRatioContextMixin`.

```tsx
import { PixelRatioContext, PixelRatioContextType } from 'react-layered-chart';

@PixelRatioContext
class ExampleComponent extends React.Component<...> {
  // For Typescript usage, you have to specify the type of the context field like so.
  context: PixelRatioContextType;

  render() {
    return <div>{this.context.pixelRatio}</div>;
  }
}
```

<hr/>

#### `PixelRatioContextProvider`

A class decorator to allow a class to provide a context value called `pixelRatio` that specified the pixel density for this chart. See [`Stack`](#stack) for more on this value. Because `Stack` and `ChartProvider` already have this behavior, you do not generally need to use this decorator. The initial value to provide on the context is read out of a prop named `pixelRatio`. If you nest multiple classes with this decorator, children will receive the value from their most immediate ancestor that specifies a `pixelRatio` prop.

You can access a mixin version at `PixelRatioContextProviderMixin`.

```tsx
import { PixelRatioContextProvider } from 'react-layered-chart';

interface Props {
  pixelRatio?: number;
}

@PixelRatioContextProvider
class ExampleParentComponent extends React.Component<Props, ...> { ... }
```

### Functions

#### `createStaticDataLoader(data, yDomains)`

Create a loader appropriate to pass to `ChartProvider` that unconditionally returns the provided static data. Useful for making simple interactive charts that have static data.

```tsx
import { createStaticDataLoader } from 'react-layered-chart';

const data = [ ... ];
const seriesId = '...';
const yDomain = figureOutYDomainFromData(data);

const dataLoader = createStaticDataLoader({
  [seriesId]: data,
}, {
  [seriesId]: yDomain
});

<ChartProvider loadData={dataLoader} .../>
```

<hr/>

#### `createSelectDataForHover(xValueIterator)`

Create a [selector](https://github.com/reactjs/reselect) that will select the currently-hovered data point according to the scheme specified by `xValueIterator`. `xValueIterator` is a function that takes `(seriesId, datum)` and returns whatever numerical value should be used to order this particular datum in the X dimension. The created selector, when invoked with a `ChartProviderState`, then returns the data point for each series immediately preceding the current hover location according to this scheme.

```tsx
import { createSelectDataForHover } from 'react-layered-chart';

function xValueIterator(seriesId, datum) {
  // Optionally inspect some external data source using `seriesId` to see how to interpret `datum`.
  return datum.someXValue;
}

const selectDataForHover = createSelectDataForHover(xValueIterator);

selectDataForHover(chartProviderState);
// -> { 'my-series-id': someDatum }
```

<hr/>

#### `wrapWithAnimatedYDomain(ComponentClass)`

Wrap the given `Component` in a new class that automatically animates the `yDomain` prop whenever it changes. Only works with `yDomain`. Animations are implemented with [react-motion](https://github.com/chenglou/react-motion).

```tsx
import { wrapWithAnimatedYDomain } from 'react-layered-chart';

interface Props {
  yDomain: Interval;
}

class ExampleComponent extends React.Component<Props, ...> {
  render() {
    return <divL{this.props.yDomain}</div>;
  }
}

export default wrapWithAnimatedYDomain(ExampleComponent);

```

<hr/>

#### `wrapDataLayerWithConnect(component)`

Wraps the given component with a new component that accepts a `seriesId` instead of `data`, `xDomain` and `yDomain`. The new component is automatically [`connect`](https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options)ed and will inject these three props based on the value of the `seriesId` prop.

**Note**: If you're using Typescript, you should explicitly parameterize the types for this function, or they may be inferred to be a too-loose value (such as `{}`). You can use `WrappedDataLayerConnectedProps` to refer to the props that will be auto-injected.

```tsx
import { WrappedDataLayerConnectedProps, wrapDataLayerWithConnect } from 'react-layered-chart';

interface CommonProps {
  color?: string;
}

type Props = CommonProps & WrappedDataLayerConnectedProps;

class ExampleComponent extends React.Component<Props, ...> { ... }

const ConnectedExampleComponent = wrapDataLayerWithConnect<CommonProps, Props>(ExampleComponent);
```

<hr/>

#### `getIndexBoundsForPointData(data, interval, xValuePath)`

Efficiently computes which span of indices in `data` intersect `interval`. Each item in `data` is assumed to have a single X value, the dot-separated path to which is given by `xValuePath`. `data` should be sorted by `xValuePath`, ascending.

**Note**: because this function is intended as a helper to make rendering more efficient, it includes items just beyond the ends of the interval as well so halfway-visible data will still be rendered.

```tsx
const data = [
  {
    value: 10,
    metadata: { timestamp: 15 }
  },
  ...
]

getIndexBoundsForPointData(data, { min: 0, max: 1000 }, 'metadata.timestamp');
// -> { firstIndex: 0, lastIndex: ... }
```

<hr/>

#### `getIndexBoundsForSpanData(data, interval, minXValuePath, maxXValuePath)`

Efficiently computes which span of indices in `data` intersect `interval`. Each item in `data` is assumed to have start and end X values, the dot-separated path to which is given by `minXValuePath` and `maxXValuePath` respectively. `data` should be sorted by `minXValuePath`, ascending.

**Note**: because this function is intended as a helper to make rendering more efficient, it includes items just beyond the ends of the interval as well so halfway-visible data will still be rendered.

```tsx
const data = [
  {
    value: 10,
    timeInterval: { from: 0, to: 47 }
  },
  ...
]

getIndexBoundsForSpanData(data, { min: 0, max: 1000 }, 'timeInterval.from', 'timeInterval.to');
// -> { firstIndex: 0, lastIndex: ... }
```

<hr/>

#### `computeTicks(scale, ticks?, tickFormat?)`

Compute the appropriate tick values and tick formatter for the given [d3-scale](https://github.com/d3/d3-scale) instance and configuration parameters. Returns `{ ticks, format }`.

`ticks` may take the following types:

- `number` or absent: it will be passed to [d3-scale's `ticks`](https://github.com/d3/d3-scale#continuous_ticks) to pick approximately that many ticks.
- `function`: it will be given the domain of the provided scale as `{ min, max }` and should return an array of numbers.
- `array`: assumed to be an array of numbers and will be used as-is.

`tickFormat` may take the following types:

- `string` or absent: it will be passed to [d3-scale's `tickFormat`](https://github.com/d3/d3-scale#continuous_tickFormat) to generate a formatter.
- `function`: assumed to be a function from number to string and will be passed back as-is.

```tsx
import * as d3Scale from 'd3-scale';

const scale = d3Scale.scaleLinear()
  .domain([ 0, 100 ])
  .range([ 20, 40 ]);

computeTicks(scale);
// -> { ticks: [ 0, 20, 40, 60, 80, 100 ], format: Function }

computeTicks(scale, [ 1, 10, 100 ]);
// -> { ticks: [ 1, 10, 100 ], format: Function }

computeTicks(scale, 2, '.5');
// -> { ticks: [ 0, 50, 100 ], format: Function }
```

<hr/>

#### `enforceIntervalBounds(interval, bounds)`

Adjust `interval` to fit within `bounds` if possible, without changing the length of `interval`. If `interval` is longer than `bounds`, the extent is maintained and `interval` is adjusted to have the same center as `bounds`.

```tsx
enforceIntervalBounds({ min: -10, max: 10 }, { min: 0, max: 100 });
// -> { min: 0, max: 20 }

enforceIntervalBounds({ min: 0, max: 120 }, { min: 0, max: 100 });
// -> { min: -10, max: 110 }
```

<hr/>

#### `enforceIntervalExtent(interval, minExtent, maxExtent)`

Adjust `interval` so its length (extent) is between `minExtent` and `maxExtent`. If adjusted, the new interval will be centered on the same point as the input interval.

```tsx
enforceIntervalExtent({ min: 0, max: 100 }, 20, 80);
// -> { min: 10, max: 90 }

enforceIntervalExtent({ min: 0, max: 100 }, 120, 200);
// -> { min: -10, max: 110 }
```

<hr/>

#### `extendInterval(interval, factor)`

Extends `interval` on each end by `length of interval * factor`.

```tsx
extendInterval({ min: 0, max: 100 }, 0.1);
// -> { min: -10, max: 110 }
```

<hr/>

#### `roundInterval(interval)`

Rounds each endpoint of `interval` to the nearest integer.

```tsx
roundInterval({ min: 0.4, max: 1.7 });
// -> { min: 0, max: 2 }
```

<hr/>

#### `niceInterval(interval)`

Uses [d3-scale's `nice`](https://github.com/d3/d3-scale#continuous_nice) to round the endpoints of `interval` to nicer values.

```tsx
niceInterval({ min: 34, max: 1454 });
// -> { min: 0, max: 1600 }
```

<hr/>

#### `mergeIntervals(intervals)`

Returns a interval that covers all the provided intervals. Returns `null` if no intervals are given.

```tsx
mergeIntervals([ { min: 0, max: 50 }, { min: -10, max: 35 } ]);
// -> { min: -10, max: 50 }

mergeIntervals([]);
// -> null
```

<hr/>

#### `intervalContains(maybeLargerInterval, maybeSmallerInterval)`

Returns `true` if `maybeLargerInterval` contains `maybeSmallerInterval`, `false` otherwise.

```tsx
intervalContains({ min: 0, max: 100 }, { min: 0, max: 50 })
// -> true

intervalContains({ min: 0, max: 100 }, { min: -50, max: 10 })
// -> false
```

<hr/>

#### `panInterval(interval, delta)`

Shift both endpoints of the interval over by the specified amount.

```tsx
panInterval({ min: 0, max: 100 }, 10);
// -> { min: 10, max: 110 }
```

<hr/>

#### `zoomInterval(interval, factor, anchorBias?)`

Zoom the given interval in/out by the specified factor. `factor > 1` zooms in, `factor < 1` zooms out. If provided, `anchorBias` should be a value on `[0, 1]` that specifies where the focus of the zoom is, where 0 means to hold the minimum value constant (therefore moving only the maximum value to perform the requested zoom) and 1 vice-versa.

```tsx
zoomInterval({ min: 0, max: 100 }, 2);
// -> { min: 25, max: 75 }

zoomInterval({ min: 0, max: 100 }, 2, 0);
// -> { min: 0, max: 50 }
```

<hr/>

### Constants

- `DEFAULT_X_DOMAIN`
- `DEFAULT_Y_DOMAIN`

### Testing

#### `CanvasContextSpy`

A minimal mock class that mimics the `CanvasRenderingContext2D` interface. An instance of this class will capture all property sets and method calls and allow you to make assertions about it. Using this class helps avoid needing a DOM or a non-browser Canvas implementation and is often sufficient for testing (as Canvas rendering is simply a series of imperative property sets and method calls).

Note that this class does _not_ support reading properties or returning values from method calls. It only intercepts sets/calls and stores the values/arguments that were provided.

Because Canvas-based rendering is entirely outside the cycle of the React rendering flow, you may want to export a stateless function to render the Canvas in addition to your component so you can import it for testing.

`CanvasContextSpy` has the following fields and methods:

- `calls`: an array of `{ method, arguments }` objects in the order the methods were called
- `properties`: an array of `{ property, value }` objects in the order the properties were set
- `operations`: a mixed array of `{ method, arguments }` and `{ property, value }` objects in the order the methods were called/properties were set
- `callsOmit(...methodNames)`: like `calls`, but excludes the specified method names
- `callsOnly(...methodNames)`: like `calls`, but includes only the specified method names

Given a class that uses Canvas to render:

```tsx
import { NonReactRender } from 'react-layered-chart';

interface Props { ... }

@NonReactRender
export default class ExampleComponent extends React.Component<Props, ...> {
  render() {
    return <canvas ref='canvas'/>;
  }

  nonReactRender() {
    _renderCanvas(this.props, this.refs.canvas.getContext('2d');
  }
}

// Exported only for testing purposes.
export function _renderCanvas(props: Props, context: CanvasRenderingContext2D) {
  // Render the things.
}
```

You can write tests that look like this (assuming you have some test/assertion frameworks already set up):

```tsx
import { CanvasContextSpy } from 'react-layered-chart';
import { _renderCanvas } from './ExampleComponent';

describe('ExampleComponent', () => {
  // Because CanvasRenderingContext2D is available at compile time (but not runtime)
  // on Node, the type definition is a bit weird and you have to use `typeof` here.
  let spy: typeof CanvasContextSpy;

  beforeEach(() => {
    spy = new CanvasContextSpy();
  });

  it('should do anything at all', () => {
    _renderCanvas({ ... }, spy);

    spy.operations.length.should.be.above(0);
  });
});
```
